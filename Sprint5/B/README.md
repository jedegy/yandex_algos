# B. Сбалансированное дерево

Гоше очень понравилось слушать рассказ Тимофея про деревья. Особенно часть про сбалансированные деревья. 
Он решил написать функцию, которая определяет, сбалансировано ли дерево.
Дерево считается сбалансированным, если левое и правое поддеревья каждой вершины отличаются по высоте не больше, чем на единицу.

![IMG](https://contest.yandex.ru/testsys/statement-image?imageId=443cf28e2af8766be8196b1dab894a5a0b4c9ee4552afa3595b6e5878e4aa5d7)

Используйте заготовки кода для данной задачи, расположенные по ссылкам:
- [с++](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/cpp/sprint5/B)
- [Java](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/java/sprint5/B)
- [js](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/js/sprint5/B)
- [Python](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/python/sprint5/B)
- [C#](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/csharp/sprint5/B)
- [go](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/go/sprint5/B)
- [Kotlin](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/kotlin/sprint5/B)
- [Swift](https://github.com/Yandex-Practicum/algorithms-templates/tree/main/swift/sprint5/B)

## Формат ввода
На вход функции подаётся корень бинарного дерева.
Следуйте следующим правилам при отправке решений:
- По умолчанию выбран компилятор Make. Если вы пишете на Swift, выберите Make Swift
- Решение нужно отправлять в виде файла с расширением соответствующем вашему языку программирования.
- Для Go укажите package main.

## Формат вывода

Функция должна вернуть `True`, если дерево сбалансировано в соответствии с критерием из условия, иначе - `False`.
